2. 基本概念
    本章描述了Lua的基本概念。
2.1 变量和类型
    Lua是一种动态类型语言。这意味着变量没有类型，值决定了变量的类型。Lua没有类型定义。所有的值带有自己类型。
    在Lua里所有值都是first-class值。这意味着所有值能被存储在变量里，作为参数传递给其他函数，和作为结果返回。
    在Lua里有八种基本类型:nil，boolean，number，string，function，userdata，thread和table。Nil是值nil的类型，它的主要目的是区
分其它值。它通常表示一个有用的值为空。Boolean是值false和true的类型。nil和false统一作为false处理；任何其他值为true。Number代表
实数。在numbers上的操作遵循C的规则，即遵守IEEE 754标准。String代表不可改变的字节序列。Lua是纯八位表示:strings能包含任意八位值
包括可嵌入的0('\0')。
    Lua能调用和使用用Lua编写的函数和用C编写的函数。(see 3.4.9)
    usedata类型允许任意C类型数据可以存储在Lua变量里。一个userdata数据是一个指向原始数据块的指针。有两种类型的userdata:full u-
ser，内存块被Lua管理和light userdata，内存块被主程序管理。Userdata没有任何预定义的操作，除了分配和身份验证之外。通过利用meta-
tables，程序员可以定义full userdata值的操作(see 2.4)。Userdata值在Lua里不能被创建和修改，只能通过C API。这保证了主程序数据的
完整性。
    thread类型表示能独立执行的线程，被实现为协程(coroutines)(see 2.6)。不要将Lua的线程和操作系统的线程弄混。Lua在所有的系统上
支持协程，即使是在不支持线程的系统上。
    table类型实现了关联数组(associative arrays)，即数组不仅能被numbers索引，还可以是任何Lua值除了nil和NaN。Tables可以包含所有
类型的值(除了nil)。值为nil的任何键不是table的一部分。反过来讲，任何不在table里的键都有一个nil值。
    Tables是Lua里的唯一的数据结构。他们能被用来表示ordinary arrays，sequences，symbol tables，sets，records，graphs，trees等
。为了表示records，Lua使用name作为索引。语言通过a.name或者语法糖a["name"]支持。在Lua里有几种方便的方法创建tables。(see 3.4.8)
    我们使用术语sequence表示一个table，它的键是大于等于1的正整数，n是sequence的长度。(see 3.4.6)
    和索引数组一样，table值可以是任何类型。特别的，因为functions是first-class值，所以table值可以包含functions。因此，tables也
可以带有方法。(see 3.4.10)
    tables的索引遵循原始相等定义。表达式a[i]和a[j]代表同一个table元素，当且仅当i和j是原始相等的。
    Tables，functions，threads和(full)userdata值是对象:变量不包含这些值，仅仅是他们的引用。赋值，参数传递和函数返回仅仅操作这
些值的引用。这些操作不意味着任何拷贝。
    库函数type返回被给值的类型。(see 6.1)
2.2 环境和全局环境
    将在3.2和3.3.3讨论，任何global name var的引用都语法转换为_ENV.var。此外，任何块被编译在一个外部的当地变量_ENV。(see 3.3.2)因
此_ENV在此块中不再是global name。
    尽管有外部_ENV变量和global names的存在，_ENV是一个完全正常的name。特别的，你能用这个名字定义新的变量和参数。每一个对glob-
al name 的引用使用_ENV，它的可见性遵循Lua的可见性规则。(see 3.5)
    任何被用来_ENV值的table叫做环境。
    Lua保持特有的环境称为全局环境。这个值在C里被保存为一个特殊的索引。在Lua里变量_G是这个值的初始化。
    当Lua编译代码块时，它初始化全局变量_ENV upvalue的值。(see load)。因此，默认情况下，在Lua里的全局变量指的是全局变量实例。
此外，所有的标准库被加载在全局环境里和几个函数操作那个环境。你能通过load(or loadfile)加载带有不同环境的代码块。(在C里，你必须
加载代码块和改变它的初始值)。
    如果你在注册的时候改变了全局环境(通过C代码或者debug库)，在此后加载的所有代码块都有新的环境。然而，加载的代码块不会被影响
。因为每一个实例都拥有它自己对环境的引用，在_ENV变量里。并且，变量_G不再被Lua更新。

2.3 错误处理
    因为Lua是一个可嵌入的扩展语言，所有Lua动作都从主程序C代码里调用来在Lua库的函数开始。(see lua_pcall)无论何时在Lua代码块汇
编或者执行中发生错误，控制权返回到主程序，由主程序采取恰当的动作。
    Lua代码可以通过调用error函数明显的生成一个错误。如果你需要在Lua代码里捕获错误，可以使用pcall或者xpcall以保护模式调用一个
函数。
    无论错误何时发生，一个error对象(也被叫做error消息)带有关于错误的信息被传播。Lua仅能生成字符串类型的错误，但是主程序可以生
成任何值的错误对象。
    当你使用xpcall或者lua_pcall的时候，你能传递一个消息处理器。当错误发生的时候，触发该处理器。该函数接受初始错误消息和返回一
个新的错误消息。因为它在错误展开栈之前被调用，因此它能获得更多关于错误的信息。这个消息处理器仍然以保护模式调用。因此在消息处
理器里发生的错误仍然会再次调用消息处理器。如果循环继续执行，Lua将打破它，并且返回一个恰当的消息。

2.4 元表和元方法
    在Lua里的每一个值都有一个元表。元表是一个普通的Lua表，它定义了原始值某些特殊操作的行为。你能通过在元表里设置特定的字段来
改变操作行为。例如。当一个非数值的值被相加时，Lua将检查这个值的元表里的__add字段。如果发现了，Lua将调用这个函数来执行加法。
    元表的键来自事件名字。相应的值被叫做元方法。在之前的例子里，事件是"add"和元方法是执行加法的函数。
    你能通过getmetatable函数查询任何值的元表。
    你能通过setmetatable函数替代tables的元表。你不能改变来自Lua的其他类型的元表。你必须使用C API。
    Tables和full userdata拥有独立的元表(尽管多个元表和userdata能共享他们的元表)。所有其他类型的值共享该值的单一元表。默认情况
下，值没有元表，但是string库为string类型设置了元表。(see 6.4)
    元表控制了一个对象的行为，比如在算数运算，排序比较，连接，长度操作和索引。一个元表也可以定义一个函数，当usedata或者table
被垃圾收集器收集的时候调用。当Lua执行某个值上的操作时，它核对该值的元表是否有一个对应的事件。如果有，该键的值控制Lua怎样执行
该操作。
    元表控制的操作接下来被列出。每个操作被相应的名字标识。每个操作的关键字是一个带有'__'前缀的字符串。例如操作"add"的键是"__add"。
    这些操作的语义通过Lua函数描述解释器怎样执行该操作是更好的。在这展示的代码仅为了说明。真正的行为被硬编码在解释器里，并且它
是更高效的比这种模拟。在这些描述里用到的所有函数在6.1描述。特别的，为了得到一个对象的元方法，我们使用表达式
    metatable(obj)[event]
    这应该读作
    rawget(getmetatable(obj) or {}, event)
    这意味着对元方法的访问不会涉及其他的元方法，并且对没有元表的对象的访问不会失败(它仅仅返回nil)。
    对于一元操作符-和#，元方法被称为虚拟的第二参数。这个额外的参数仅仅是简化了Lua的内部实现。在将来的版本里也许会被移除，因此
它不会出现在下面的代码中。
    * "add"
    * "sub"
    * "mul"
    * "div"
    * "mod"
    * "pow"
    * "unm"
    * "concat"
    * "len"
    * "eq"
    * "lt"
    * "le"
    * "index"
    * "newindex"
    * "call"

2.5 垃圾收集器
    Lua执行自动内存管理。这意味着你既不必担心申请内存为了新的对象也不必担心当对象不再需要时释放它。Lua通过运行垃圾收集器收集
所有的死亡对象(即这些对象不再被Lua访问)自动管理内存。所有被Lua使用的内存都是自动管理的对象:strings，tables，userdata，funct-
ions，threads，internal sructures等。
    Lua实现了一个增量的标记清除收集器。它使用两个数字来控制垃圾收集循环:垃圾收集器暂停和垃圾收集器步乘。两者都使用百分点作为
单位。
    垃圾收集器暂停控制了在开始一个新的循环之前等待多久。越大的值使收集器越低侵略。低于100的值意味着收集器不需要等待，即可开始
一个新的循环。值200意味着收集器需要等到已使用内存加倍后才开始一个新的循环。
    垃圾收集器步乘控制垃圾收集相对内存申请的速度。越大的值使收集器更具侵略性，并且增加了每个增量步的大小。小于100的值意味着
垃圾收集器太慢了和导致垃圾收集器不能完成一个循环。默认是200，意味着垃圾收集是内存申请速度的两倍。
    你能通过调用C的lua_gc或者Lua的collectgarbage来改变这些值。你也能用这些函数直接控制这些收集器(例如停止和重启它)。
    在Lua5.2里有一个试验性的功能。你能改变收集器的操作模式从incremental到generational。
2.5.1 垃圾收集器的元方法
    你能为tables设置垃圾收集器的元方法和使用C API为了full userdata。这些元方法也叫做finalizers。finalizers允许你协调额外的资
源管理和Lua的垃圾收集。
    对于一个被终结的对象(table or userdata)当被收集的时候，你必须标记它为终结。当你设置它的元表和元表有一个"__gc"字段时，你标
记一个对象为终结。注意:如果你设置一个元表没有__gc字段，后来在那个元表里创建了那个字段，这个对象未被标记为finalization。然而，
在一个对象被标记后，你能自由的改变元表的__gc字段。
    当一个被标记的对象可被回收时，它不被垃圾收集器立即收集。相反，Lua将它放在列表里。在收集的时候，Lua将对列表里的每个对象执
行如下函数:
    function gc_event(obj)
        local h = metatable(obj).__gc
        if type(h) == "function" then
            h(obj)
        end
    end
2.5.2 弱表
    弱表是一个表，它的元素是弱引用。一个弱引用被垃圾收集器忽略。换言之，如果对一个对象的唯一引用是弱引用，那么垃圾收集器将收
集该对象。
    一个弱表能有弱键，弱值或者都有。一个带有弱键的表允许它的键被收集，但是阻止它的值被收集。一个既有弱键又有弱值的表它的键和
值都允许被收集。在任何情况下，如果键或者值被收集，完整的对将在table中删除。表的弱性被元表的__mode字段控制。如果__mode字段是一
个包含字符'k'的字符串，该表的键是弱的。如果__mode包含'v'，该表的值是弱的。
    弱键强值的表也叫蜉蝣表。在蜉蝣表里，它的值被认为是可达的仅当它的键是可达的。特别的，如果对于键的唯一引用是它的值，该对将
被移除。
    表的弱性的改变会影响下一次的垃圾收集。如果你改变弱性到一个更强的模式，Lua也许仍然会收集一些来自表中项在改变生效之前。
    
