7 独立的Lua(Lua Standalone)
    尽管Lua被设计为可嵌入在主C程序的可扩展语言，但是也经常被用作独立语言。作为独立语言的Lua解释器，被简单的称为lua，以标准分
发被提供。独立的解释器包含所有标准库，包括调式库。使用方法如下:
    lua [options] [script [args]]
    options如下:
        * -e stat: 执行字符串stat
        * -l mode: "require" mod
        * -i: 运行脚本后进入交互模式
        * -v: 打印版本信息
        * -E: 忽略环境变量
        * --: 停止处理选项。
        * -: 执行stdin作为文件且停止处理选项。
    在处理完选项之后，lua运行给定的脚本，args作为参数传递。当无参数调用时，lua与lua -v -i一样，标准输入是终端。
    当使用参数-E调用时，解释器检查环境变量LUA_INIT_5_2(如果未被定义是LUA_INIT)在运行任何参数之前。如果变量内容有@filename格式
那么lua执行文件。否则，lua执行字符串。
    当使用参数-E调用时，除了忽略LUA_INIT,Lua也忽略LUA_PATH和LUA_CPATH，使用被定义在luaconf.h中的默认路径设置package.path和pa-
ckage.cpath。
    所有的选项按照顺序被处理，除了-i和-E。例如
        $lua -e 'a=1' -e 'print(a)' script.lua
    将设置a等于1，然后打印a的值，最后以无参数运行文件script.lua。
    在开始运行脚本之前，lua在arg表里收集在命令行里的所有参数。脚本名字被存储在索引0，脚本名后的第一个参数是索引1等等。脚本名
之前的任何参数位于负索引。例如，如下调用
        $lua -la b.lua t1 t2
    解释器首先运行文件a.lua，随后创建表
        arg = { [-2] = "lua", [-1] = "-la",
                [0] = "b.lua",
                [1] = "t1", [2] = "t2"
            }
    最后运行文件b.lua。该脚本以arg[1], arg[2]...作为参数被调用。它也可以使用ararg表达式'...'访问这些参数。
    在交互模式下，如果你写了一个不完整的申明，解释器将通过引发一个不同的提示来等待知道完整。
    在脚本中以不被保护的方式下出错，解释器将错误输出到标准错误流。如果错误对象是一个字符串，解释器增加一个stack traceback。否
则，如果错误对象有元方法__tostring，解释器将调用该元方法产生最终消息。最后，如果错误对象是nil，解释器将不报告此错误。
    当正常结束时，解释器关闭主要的Lua state(see lua_close)。脚本通过调用os.exit来避免该步。
